package trafficui;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;

import traffic.Board;
import traffic.MoveNode;
import traffic.Piece;
import traffic.PieceType;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * The UI portion of the Traffic Jam sliding pieces puzzle
 */
public class TrafficUI {
    
    // Pixel size of each square on the board grid
    public static int GRID_ELEM_SIZE = 50;
    
    // Default config filename 
    public static String DEFAULT_CFG_FNAME = "config";
    
    // Image of the 'solved' configuration, so players can see it
    public static String DEFAULT_SOLVED_IMAGE = "solved.png";
    
    // Label on the active board
    public static String ACTIVE_BOARD_LABEL = "Active ('ctrl' for  alt direction)";
    
    // Label on the solution image
    public static String SOLUTION_LABEL = "Solved";
    
    // The underlying 'Board' object, which implements the guts of the puzzle
    public static Board theBoard = null;
    
    // An array of puzzle pieces - 'PieceButton' is a combination of a JButton
    // and a 'Piece' board element
    public static List<PieceButton> buttons = new ArrayList<PieceButton>();
    
    // The 'Next' and 'Solve' buttons
    public static JButton btnNext = null;
    public static JButton btnSolve = null;
    
    // The main frame which contains the PieceButtons
    public static JFrame theWindow = new JFrame();
    
    // A list of moves required to achieve the solved board
    // Each node represents a board layout, a piece to move, and the direction
    // of the move. This list gets generated by hitting the 'Solve' button
    public static List<MoveNode> solution = new LinkedList<MoveNode>();
    
    // Indicates that the next move is to be in the secondary direction
    // (The user hits the 'ctrl' or 'a' key to trigger this value)
    public static boolean altDir = false;
    
    /**
     * The main Traffic Jam UI routine
     * @param a     The command-line arguments (optional, config filename)
     */
    public static void main(String[] a) {
        
        // Get the command line param, if provided, to load the initial and
        // final board layout (from a config file)
        if (a.length > 1) {
            System.err.println("Too many command line arguments.");
            return;
        }
        
        // Read the config file, generate the core logic Board object, store
        // the solution array. Use cmd line arg for config data if specified
        theBoard = (a.length == 1) ? new Board(a[0]) : new Board(true); 
        
        // Configure the main window
        theWindow.setLayout(null);
        theWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        theWindow.setBounds(0, 0, 500, 375);

        // Create labels
        JLabel 
            activeBoardLabel = new JLabel(ACTIVE_BOARD_LABEL),
            solvedBoardLabel = new JLabel(SOLUTION_LABEL);        
        
        // Size and positon the active and solution labels
        activeBoardLabel.setBounds(
            0,
            GRID_ELEM_SIZE * theBoard.getHeight(),
            GRID_ELEM_SIZE * theBoard.getWidth(),
            GRID_ELEM_SIZE
        );
        
        solvedBoardLabel.setBounds(
            GRID_ELEM_SIZE * (theBoard.getWidth() + 2),
            GRID_ELEM_SIZE * theBoard.getHeight(),
            GRID_ELEM_SIZE * theBoard.getWidth(),
            GRID_ELEM_SIZE
        );
        
        // Add the labels to the window
        theWindow.add(activeBoardLabel);
        theWindow.add(solvedBoardLabel);
        
        // Populate the PieceButtons on the board, and listen for events
        _addButtons(new TrafficUIEvents(), new SolutionEvents());
		
        // Also listen for keystroke events
		theWindow.addKeyListener(new KeyEvents());

		// It's important that the board, and not the buttons, should always be
		// focused and visible
		theWindow.setFocusable(true);
		theWindow.setVisible(true);
    }
    
    
    /**
     * Helper method to place buttons on the board (both the buttons which 
     * represent the pieces, and the buttons for 'Solve' and 'Next')
     * 
     * @param UIEvents  Event handler class for clicks on pieces 
     * @param solutionEvents    Event handler class for 'Solve' and 'Next'
     */
    private static void _addButtons(
        TrafficUIEvents UIEvents, 
        SolutionEvents solutionEvents
    ) {

        // Create new button objects for each piece
        PieceButton pb = null;
        PieceType pt = null;
        for (Piece p : theBoard.getPieces()) {
            
            // Since we're iterating over the pieces, this is as good a place
            // as any to store the set of possible moves
            theBoard.storeMoves(p);
            
            // Create the button instance
            pb = new PieceButton(p);
            
            // Position the button based on the piece size and position
            pt = p.getType();
            pb.setBounds(
                GRID_ELEM_SIZE * p.getLeftPos(),
                GRID_ELEM_SIZE * p.getTopPos(),
                GRID_ELEM_SIZE * pt.getWidth(), 
                GRID_ELEM_SIZE * pt.getHeight()
            );
            
            // register the listener for the button click
            pb.addActionListener(UIEvents);
            
            // add the newly created button to the list
            buttons.add(pb);
        }
        
        // Create a representation of the solved layout
        JButton b = null;
        List<PieceType> pTypes = theBoard.getTypes();
        int width = theBoard.getWidth();
        int solution[] = theBoard.getSolvedBoard();
        for (int pid = -1, idx = 0, max = solution.length; idx < max; ++idx) {
        	pid = solution[idx];
        	if (pid != -1) {
        		pt = pTypes.get(pid);
        		b = new JButton();
        		b.setBounds(
                    GRID_ELEM_SIZE * (width + 2 + idx % width),
                    GRID_ELEM_SIZE * (idx / width),
                    GRID_ELEM_SIZE * pt.getWidth(),
                    GRID_ELEM_SIZE * pt.getHeight()
        		);
        		b.setEnabled(false);
            	theWindow.add(b);
        	}
        }
        
        // create and place the 'Solve' and 'Next' buttons, with listener
        
        // First 'Solve'
        btnSolve = new JButton("Solve");
        btnSolve.setBounds(
                0, 
                (theBoard.getHeight() + 1) * GRID_ELEM_SIZE, 
                (int)(GRID_ELEM_SIZE * 1.33), 
                GRID_ELEM_SIZE
        );
        btnSolve.addActionListener(solutionEvents);
        
        // And then 'Next'
        btnNext = new JButton("Next");
        btnNext.setBounds(
            (int)(GRID_ELEM_SIZE * 1.33), 
            (theBoard.getHeight() + 1) * GRID_ELEM_SIZE, 
            (int)(GRID_ELEM_SIZE * 1.33), 
            GRID_ELEM_SIZE
        );
        btnNext.setEnabled(false);
        btnNext.addActionListener(solutionEvents);

        // add all the buttons to the main window
        theWindow.add(btnSolve);
        theWindow.add(btnNext);
        for (PieceButton pieceb : buttons) {
            theWindow.add(pieceb);
        }

    }
    
    /**
     * Reposition and re-paint buttons when layout changes
     */
    public static void redrawPieces() {

        // We need the contained Piece and PieceType objects to
        // determine the new positions and dimensions
        Piece p = null;
        PieceType pt = null;

        // For each Piece, reset the UI bounds (left, top, width, height)
        for (PieceButton pb : buttons) {

            p = pb.getPiece();
            pt = p.getType();
            
            pb.setBounds(
                GRID_ELEM_SIZE * p.getLeftPos(),
                GRID_ELEM_SIZE * p.getTopPos(),
                GRID_ELEM_SIZE * pt.getWidth(), 
                GRID_ELEM_SIZE * pt.getHeight()
            );
            pb.repaint();
        }
        
        TrafficUI.theWindow.requestFocus();
    }
}
